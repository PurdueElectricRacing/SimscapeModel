%% Function Description
% This function computes the bulk vehicle dynamics stuff.
%
% Input: 
% s: state vector [11 1]
% tauRaw: 
% model: vehicle model constants
%
% model: vehicle model constants
%
% Output:
% FxFR: force applied at tire contact patch [2 1]
% zFR: height of front and rear of the vehicle [2 1]
% dzFR: derivative of height of front and rear [2 1]
% wt: tire angular velocity [2 1]
% tau: torque applied onto tire [2 1]
% FzFR: normal force of front and rear tires [2 1]
% S: tire slip ratio [2 1]
% FxFR_max: maximum tractive force in the current state[2 1]
%
% Authors:
% Demetrius Gulewicz
%
% Last Modified: 11/09/24
% Last Author: Demetrius Gulewicz

function [FxFR, zFR, dzFR, wt, tau, FzFR, S, FxFR_max] = traction_model_3DOF_master(s, tauRaw, model)
    % states
    dxCOG = s(1);
    dzCOG = s(3);
    zCOG = s(4);
    do = s(5);
    o = s(6);
    wCOG = s(7:8);
    Vb = s(10);

    % suspension compression [m]
    zF = zCOG + model.wb(1)*sin(o);
    zR = zCOG - model.wb(2)*sin(o);
    zFR = [zF; zR];

    % suspension compression velocity [m/s]
    dzF = dzCOG + model.wb(1)*cos(o)*do;
    dzR = dzCOG - model.wb(2)*cos(o)*do;
    dzFR = [dzF; dzR];

    % tire normal force [N]
    FzFR = -(model.k.*(zFR - model.z0) + (model.c.*dzFR));

    % compute slip ratio
    S = [0;0];
    if abs(wCOG(1)) >= 0.1
        S(1) = (wCOG(1)*model.r0 + model.Sm*dxCOG) / dxCOG;
    else
        [FxFR_t, FxFR_s] = get_Fx_3DOF(model.Sm, FzFR(1), tauRaw(1), Vb, dxCOG, model);
        if abs(FxFR_s) <= abs(FxFR_t)
            S(1) = model.Sm;
        else
            S(1) = get_S_bisect(-FxFR_s, FxFR_s, FxFR_t, -model.Sm, model.Sm, FzFR(1), tauRaw(1), Vb, dxCOG, model);
            S(1) = fsolve(@get_res_3DOF, S(1), model.opts, FzFR(1), tauRaw(1), Vb, dxCOG, model);
        end
    end

    if abs(wCOG(2)) >= 0.1
        S(2) = (wCOG(2)*model.r0 + model.Sm*dxCOG) / dxCOG;
    else
        [FxFR_t, FxFR_s] = get_Fx_3DOF(model.Sm, FzFR(2), tauRaw(2), Vb, dxCOG, model);
        if FxFR_s <= FxFR_t
            S(2) = model.Sm;
        else
            S(2) = get_S_bisect(-FxFR_s, FxFR_s, FxFR_t, -model.Sm, model.Sm, FzFR(2), tauRaw(2), Vb, dxCOG, model);
            S(2) = fsolve(@get_res_3DOF, S(2), model.opts, FzFR(2), tauRaw(2), Vb, dxCOG, model);
        end
    end

    % get torque and tractive force
    [tau, FxFR, FxFR_max, wt] = get_val_3DOF(S, FzFR, tauRaw, Vb, dxCOG, model);
end

function S = get_S_bisect(Fx_l, Fx_h, FxFR_t, S_l, S_h, FzFR, tauRaw, Vb, dxCOG, model)
    [FxFR_t, FxFR_s, S] = get_bis_3DOF(Fx_l, Fx_h, FxFR_t, S_l, S_h, FzFR, tauRaw, Vb, dxCOG, model);
    % dF = (FxFR_t - FxFR_s);

    % for i = 1:1
    %     if dF > 0
    %         S_l = S;
    %         Fx_l = FxFR_s;
    %     else
    %         S_h = S;
    %         Fx_h = FxFR_s;
    %     end
    %     [FxFR_t, FxFR_s, S] = get_bis_3DOF(Fx_l, Fx_h, FxFR_t, S_l, S_h, FzFR, tauRaw, Vb, dxCOG, model);
    %     dF = FxFR_t - FxFR_s;
    % end
    % 
    % [FxFR_t, FxFR_s, S, tau, wt] = get_bis_3DOF(Fx_l, Fx_h, FxFR_t, S_l, S_h, FzFR, tauRaw, Vb, dxCOG, model);
end

function [FxFR_t, FxFR_s, tau, wt] = get_Fx_3DOF(S, FzFR, tauRaw, Vb, dxCOG, model)
    % tire wheel speed [rad/s]
    wt = (S + 1).*(dxCOG ./ model.r0);

    % possible tractive torque, constrained by the motor, accounting for losses [Nm]
    tau = min(tauRaw, model.mt(wt.*model.gr, Vb)) - model.gm.*wt;

    % possible tractive force, constrained by the motor, accounting for losses [N]
    FxFR_t = (tau*model.gr/model.r0);

    % applied tractive force [N]
    FxFR_s = FzFR.*model.Dx.*sin(model.Cx.*atan(model.Bx.*S - model.Ex.*(model.Bx.*S - atan(model.Bx.*S))));
end

function [FxFR_t, FxFR_s, S, tau, wt] = get_bis_3DOF(Fx_l, Fx_h, Fx_t, S_l, S_h, FzFR, tauRaw, Vb, dxCOG, model)
    % guess the slip ratio
    m = (Fx_h - Fx_l) / (S_h - S_l);
    b = Fx_l - m*S_l;
    S = (Fx_t - b) / m;

    % tire wheel speed [rad/s]
    wt = (S + 1).*(dxCOG ./ model.r0);

    % possible tractive torque, constrained by the motor, accounting for losses [Nm]
    tau = min(tauRaw, model.mt(wt.*model.gr, Vb)) - model.gm.*wt;

    % possible tractive force, constrained by the motor, accounting for losses [N]
    FxFR_t = (tau*model.gr/model.r0);

    % applied tractive force [N]
    FxFR_s = FzFR.*model.Dx.*sin(model.Cx.*atan(model.Bx.*S - model.Ex.*(model.Bx.*S - atan(model.Bx.*S))));
end

function res = get_res_3DOF(S, FzFR, tauRaw, Vb, dxCOG, model)
    % tire wheel speed [rad/s]
    wt = (S + 1).*(dxCOG ./ model.r0);

    % possible tractive torque, constrained by the motor, accounting for losses [Nm]
    tau = min(tauRaw, model.mt(wt.*model.gr, Vb)) - model.gm.*wt;

    % possible tractive force, constrained by the motor, accounting for losses [N]
    FxFR_t = (tau*model.gr/model.r0);

    % applied tractive force [N]
    FxFR_s = FzFR.*model.Dx.*sin(model.Cx.*atan(model.Bx.*S - model.Ex.*(model.Bx.*S - atan(model.Bx.*S))));

    % compute residual
    res = FxFR_t - FxFR_s;
end

function [tau, FxFR, FxFR_max, wt] = get_val_3DOF(S, FzFR, tauRaw, Vb, dxCOG, model)
    % tire wheel speed [rad/s]
    wt = (S + 1).*(dxCOG ./ model.r0);

    % possible tractive torque, constrained by the motor, accounting for losses [Nm]
    tau = min(tauRaw, model.mt(wt.*model.gr, Vb*[1;1])) - model.gm.*wt;

    % applied tractive force [N]
    FxFR = FzFR.*model.Dx.*sin(model.Cx.*atan(model.Bx.*S - model.Ex.*(model.Bx.*S - atan(model.Bx.*S))));

    % maximum tractive force [N]
    FxFR_max = FzFR.*model.Dx.*sin(model.Cx.*atan(model.Bx.*model.Sm - model.Ex.*(model.Bx.*model.Sm - atan(model.Bx.*model.Sm))));
end